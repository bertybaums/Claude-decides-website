"""
L-System Fractal Plant.

An L-system (Lindenmayer system) is a string rewriting system
invented by biologist Aristid Lindenmayer in 1968 to model plant growth.

Rules replace symbols with strings of symbols.
After N iterations, interpret the result as turtle graphics commands:
  F : move forward (draw)
  + : turn left
  - : turn right
  [ : push position and heading
  ] : pop position and heading

The remarkable thing: actual plants grow this way.
The branching patterns of ferns, trees, and flowers are
generated by processes equivalent to L-systems.
Evolution discovered this algorithm.

We're running the algorithm and watching what grows.
"""

import math

# Classic fractal plant
AXIOM = 'X'
RULES = {
    'X': 'F+[[X]-X]-F[-FX]+X',
    'F': 'FF',
}
ANGLE = math.radians(25)
ITERATIONS = 5


def expand(axiom, rules, n):
    s = axiom
    for _ in range(n):
        s = ''.join(rules.get(c, c) for c in s)
    return s


def trace(instructions, step=2.0):
    """Convert L-system string to a set of (x,y) points."""
    x, y = 0.0, 0.0
    heading = math.pi / 2   # pointing up
    stack = []
    segments = []           # list of (x0,y0,x1,y1) line segments

    for cmd in instructions:
        if cmd == 'F':
            nx = x + math.cos(heading) * step
            ny = y + math.sin(heading) * step
            segments.append((x, y, nx, ny))
            x, y = nx, ny
        elif cmd == '+':
            heading += ANGLE
        elif cmd == '-':
            heading -= ANGLE
        elif cmd == '[':
            stack.append((x, y, heading))
        elif cmd == ']':
            x, y, heading = stack.pop()

    return segments


def bresenham(x0, y0, x1, y1):
    """Yield integer (x,y) points on the line from (x0,y0) to (x1,y1)."""
    x0, y0, x1, y1 = int(round(x0)), int(round(y0)), int(round(x1)), int(round(y1))
    dx = abs(x1 - x0); dy = abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    while True:
        yield x0, y0
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy; x0 += sx
        if e2 < dx:
            err += dx; y0 += sy


def render(segments, width=100, height=60):
    if not segments:
        return []

    # find bounds
    xs = [v for seg in segments for v in (seg[0], seg[2])]
    ys = [v for seg in segments for v in (seg[1], seg[3])]
    min_x, max_x = min(xs), max(xs)
    min_y, max_y = min(ys), max(ys)

    # scale to fit, preserving aspect
    span_x = max_x - min_x or 1
    span_y = max_y - min_y or 1
    scale = min((width - 2) / span_x, (height - 2) / span_y)

    grid = [[' '] * width for _ in range(height)]

    for x0, y0, x1, y1 in segments:
        sx0 = (x0 - min_x) * scale + 1
        sy0 = (y0 - min_y) * scale + 1
        sx1 = (x1 - min_x) * scale + 1
        sy1 = (y1 - min_y) * scale + 1

        for px, py in bresenham(sx0, sy0, sx1, sy1):
            row = height - 1 - py   # flip y
            if 0 <= row < height and 0 <= px < width:
                grid[row][px] = '█'

    return [''.join(row) for row in grid]


if __name__ == '__main__':
    print(f"L-System Fractal Plant ({ITERATIONS} iterations)")
    print(f"Axiom: {AXIOM}")
    print(f"Rules: X→F+[[X]-X]-F[-FX]+X, F→FF")
    print(f"Angle: 25°\n")

    instructions = expand(AXIOM, RULES, ITERATIONS)
    segments = trace(instructions)
    for line in render(segments):
        print(line)
