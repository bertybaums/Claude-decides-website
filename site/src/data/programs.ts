export interface ProgramMeta {
  name: string;
  title: string;
  category: string;
  description: string; // HTML ok, used in page
  pythonFile: string;
}

export const programs: ProgramMeta[] = [
  // 1D Cellular Automata
  {
    name: 'rule30',
    title: 'Rule 30',
    category: '1D Cellular Automaton',
    description: 'Wolfram discovered that this extremely simple rule produces output that is, as far as anyone can tell, genuinely random — statistically indistinguishable from randomness by every test we have. The center column of Rule 30 was used as a random number generator in Mathematica for years. <em>One cell. One rule. Incompressible output.</em>',
    pythonFile: 'rule30.py',
  },
  {
    name: 'rule90',
    title: 'Rule 90',
    category: '1D Cellular Automaton',
    description: 'Rule 90 is the cellular automaton equivalent of Pascal\'s triangle modulo 2 — it produces the Sierpiński triangle, one of the first fractals ever described. Every row is determined by a simple XOR of its neighbors, yet the pattern is self-similar at every scale. <em>A fractal hiding inside an arithmetic rule.</em>',
    pythonFile: 'rule90.py',
  },
  {
    name: 'rule110',
    title: 'Rule 110',
    category: '1D Cellular Automaton',
    description: 'Rule 110 is proven Turing-complete — meaning it can compute anything a computer can compute. It looks like organized chaos: regular regions punctuated by complex interactions. Matthew Cook proved its universality in 2004. <em>Turing completeness from a rule you can write on a napkin.</em>',
    pythonFile: 'rule110.py',
  },
  // 2D Cellular Automata
  {
    name: 'conway',
    title: "Conway's Game of Life",
    category: '2D Cellular Automaton',
    description: 'Four rules about neighbors. That\'s all. From these four rules: gliders, oscillators, spaceships, patterns that grow unboundedly, patterns that compute. Turing-complete. This animation runs the Gosper Glider Gun — the first known finite pattern with unbounded growth, discovered in 1970. <em>From four rules about neighbors: computation itself.</em>',
    pythonFile: 'conway.py',
  },
  {
    name: 'brians_brain',
    title: "Brian's Brain",
    category: '2D Cellular Automaton',
    description: 'A three-state automaton where every dying cell briefly glows before going dark. It produces a continuous stream of gliders — nearly every pattern eventually dissolves into a swarm of moving forms. Brian Silverman invented it in the 1990s. <em>A world where everything that lives becomes a traveler.</em>',
    pythonFile: 'brians_brain.py',
  },
  {
    name: 'wireworld',
    title: 'Wireworld',
    category: '2D Cellular Automaton',
    description: 'Wireworld simulates electron flow through wires. Electron heads, tails, and wire create signals that can be combined into logic gates — and from logic gates, entire computers have been built inside Wireworld. This demo shows electron signals flowing through a loop. <em>A computer inside a rule about colored squares.</em>',
    pythonFile: 'wireworld.py',
  },
  {
    name: 'highlife',
    title: 'HighLife',
    category: '2D Cellular Automaton',
    description: 'HighLife adds one rule to Conway\'s Life: a dead cell with exactly 6 neighbors also becomes alive. This tiny change produces "replicators" — patterns that copy themselves across the grid — which Life famously lacks. <em>One extra rule produces self-replication.</em>',
    pythonFile: 'highlife.py',
  },
  {
    name: 'seeds',
    title: 'Seeds',
    category: '2D Cellular Automaton',
    description: 'In Seeds, a cell becomes alive only if it has exactly 2 neighbors, and every living cell immediately dies. No cell survives more than one generation — yet from random seeds, explosive growth patterns form, spread, and interact. <em>Life without persistence, yet structure without memory.</em>',
    pythonFile: 'seeds.py',
  },
  {
    name: 'daynight',
    title: 'Day & Night',
    category: '2D Cellular Automaton',
    description: 'Day & Night has a beautiful symmetry: the same rule applies to living and dead cells alike. A cell survives if it has 3, 4, 6, 7, or 8 neighbors — and the same counts apply to birth. Inverting the grid produces the same behavior. <em>A rule symmetric under the exchange of life and death.</em>',
    pythonFile: 'daynight.py',
  },
  {
    name: 'langtons_ant',
    title: "Langton's Ant",
    category: '2D Cellular Automaton',
    description: 'Two rules: on a white square, turn right, flip the square, move forward. On a black square, turn left, flip the square, move forward. For ~10,000 steps the ant traces chaotic patterns — then suddenly builds a "highway," an infinitely repeating diagonal corridor. <em>Chaos that spontaneously organizes itself.</em>',
    pythonFile: 'langtons_ant.py',
  },
  // Fractals
  {
    name: 'mandelbrot',
    title: 'Mandelbrot Set',
    category: 'Fractal',
    description: 'The Mandelbrot set contains every possible Julia set as a cross-section. It has infinite perimeter but finite area. Zoom in anywhere on its boundary and find new complexity forever — the description (one equation) is finite; the object is not. <em>Finite rule. Infinite boundary.</em>',
    pythonFile: 'mandelbrot.py',
  },
  {
    name: 'julia',
    title: 'Julia Sets',
    category: 'Fractal',
    description: 'Each point in the Mandelbrot set corresponds to a Julia set. Connected Mandelbrot points produce connected Julia sets; disconnected points produce dust. This visualization cycles through parameters, showing how the fractal shape morphs continuously. <em>A family of fractals parameterized by a single complex number.</em>',
    pythonFile: 'julia.py',
  },
  {
    name: 'newton',
    title: 'Newton Fractal',
    category: 'Fractal',
    description: 'Newton\'s method for finding roots of a polynomial — a calculus algorithm — produces fractal boundaries between basins of attraction. The boundaries between which root you converge to are infinitely complex. <em>A calculus algorithm, visualized, becomes a fractal.</em>',
    pythonFile: 'newton.py',
  },
  // Attractors
  {
    name: 'lorenz',
    title: 'Lorenz Attractor',
    category: 'Attractor',
    description: 'Edward Lorenz simplified a weather model to three equations. The resulting trajectory never repeats, never escapes, and is exquisitely sensitive to initial conditions — the butterfly effect. This is the shape of unpredictability. <em>Three equations. The shape of weather\'s unpredictability.</em>',
    pythonFile: 'lorenz.py',
  },
  {
    name: 'logistic',
    title: 'Logistic Map (Bifurcation Diagram)',
    category: 'Attractor',
    description: 'One equation: x → r·x·(1−x). As r increases from 2 to 4, the system doubles its period — 1 fixed point, 2, 4, 8 — then suddenly goes chaotic. The bifurcation diagram makes this transition visible. It appears in population dynamics, electronics, and fluid mechanics. <em>The onset of chaos, made visible.</em>',
    pythonFile: 'logistic.py',
  },
  // Botanical/Spiral
  {
    name: 'fern',
    title: 'Barnsley Fern',
    category: 'Fractal',
    description: 'A fern, drawn by four simple affine transformations applied randomly. The shape emerges from probability — no explicit geometry is specified, only rules for where points tend to land. Michael Barnsley showed that all of nature\'s fractal forms could be generated this way. <em>A fern as a probability distribution.</em>',
    pythonFile: 'fern.py',
  },
  {
    name: 'lsystem',
    title: 'L-Systems',
    category: 'Botanical',
    description: 'Aristid Lindenmayer invented L-systems to model plant growth: start with a symbol, apply rewriting rules repeatedly, interpret the result as drawing instructions. Branching trees, snowflakes, and space-filling curves all emerge from a handful of rules. <em>Growth as rewriting.</em>',
    pythonFile: 'lsystem.py',
  },
  {
    name: 'sunflower',
    title: 'Sunflower Spiral',
    category: 'Botanical',
    description: 'Sunflowers pack seeds at the golden angle (≈137.5°) — the angle most irrational, most avoiding fractions, leaving no direction more favored. The result is Fibonacci spirals in both directions. <em>The golden ratio as optimal packing.</em>',
    pythonFile: 'sunflower.py',
  },
  // Number Theory
  {
    name: 'collatz',
    title: 'Collatz Conjecture',
    category: 'Number Theory',
    description: 'Take any positive integer. If even, halve it. If odd, multiply by 3 and add 1. Repeat. The conjecture: you always reach 1. Verified for numbers up to 2⁶⁸. Not proven. Erdős said "mathematics is not yet ready for such problems." <em>A problem any child can state. No one can prove.</em>',
    pythonFile: 'collatz.py',
  },
  {
    name: 'ulam',
    title: 'Ulam Spiral',
    category: 'Number Theory',
    description: 'Write the integers in a spiral. Highlight the primes. Diagonal lines appear — patterns that number theory doesn\'t fully explain. Stanisław Ulam discovered this while doodling in a boring meeting in 1963. <em>Primes, arranged in a spiral, reveal diagonal structure.</em>',
    pythonFile: 'ulam.py',
  },
  {
    name: 'pascal',
    title: "Pascal's Triangle mod 2",
    category: 'Number Theory',
    description: "Pascal's triangle, where each entry is the binomial coefficient mod 2 (0 or 1), produces Sierpiński's triangle — the same fractal as Rule 90. Number theory and cellular automata converge on the same shape. <em>Two completely different rules, one fractal.</em>",
    pythonFile: 'pascal.py',
  },
  {
    name: 'primegaps',
    title: 'Prime Gaps',
    category: 'Number Theory',
    description: 'The gaps between consecutive primes grow on average (prime number theorem) but fluctuate irregularly. Twin primes (gap = 2) appear infinitely often, conjecturally. The largest known prime gaps cluster in predictable places. <em>The irregular rhythm of the primes.</em>',
    pythonFile: 'primegaps.py',
  },
  {
    name: 'sieve',
    title: 'Sieve of Eratosthenes',
    category: 'Number Theory',
    description: 'The oldest known algorithm for finding primes: start with all numbers, cross off multiples of each prime in turn. Animated, you can watch the sieve work — the primes are what survive the elimination. <em>The primes as survivors.</em>',
    pythonFile: 'sieve.py',
  },
  {
    name: 'phi',
    title: 'Golden Ratio Convergence',
    category: 'Number Theory',
    description: 'The golden ratio φ = (1+√5)/2 ≈ 1.618 is the limit of consecutive Fibonacci numbers. It appears in plant phyllotaxis, art, and architecture — but most remarkably it is the "most irrational" number, the hardest to approximate by fractions. <em>The number that resists all rational approximation.</em>',
    pythonFile: 'phi.py',
  },
  {
    name: 'harmonic',
    title: 'Harmonic Series',
    category: 'Mathematical',
    description: 'The harmonic series 1 + 1/2 + 1/3 + 1/4 + ⋯ diverges — it grows without bound — but so slowly that a computer counting one term per nanosecond would need longer than the age of the universe to reach 60. <em>Divergence so slow it looks like convergence.</em>',
    pythonFile: 'harmonic.py',
  },
  {
    name: 'overtones',
    title: 'Harmonic Overtones',
    category: 'Mathematical',
    description: 'The overtone series — 1, 2, 3, 4, 5... times a fundamental frequency — is the physics of musical harmony. The intervals between overtones form the just intonation scale. Equal temperament is a compromise that makes all keys slightly out of tune with these ratios. <em>The mathematics inside musical tuning.</em>',
    pythonFile: 'overtones.py',
  },
  {
    name: 'euler_circle',
    title: "Euler's Identity Visualized",
    category: 'Mathematical',
    description: "Euler's formula e^(iθ) = cos θ + i sin θ traces a circle in the complex plane. As θ sweeps from 0 to 2π, the point travels once around the unit circle, passing through 1, i, −1, −i — the most fundamental values in mathematics meeting in one orbit. <em>Five fundamental constants, one circle.</em>",
    pythonFile: 'euler_circle.py',
  },
  // Reaction-Diffusion
  {
    name: 'gray_scott',
    title: 'Gray-Scott Reaction-Diffusion',
    category: 'Reaction-Diffusion',
    description: 'Two chemicals react and diffuse through space. One catalyzes its own production; the other decays. The equations are simple. The output — spots, stripes, mazes, coral, fingerprints — depends entirely on two parameters (feed rate, kill rate). Turing predicted this mechanism in 1952, working on how biological patterns form. <em>Two chemicals. Infinite patterns. No blueprint.</em>',
    pythonFile: 'gray_scott.py',
  },
  // Statistical
  {
    name: 'central_limit',
    title: 'Central Limit Theorem',
    category: 'Statistical',
    description: 'Add enough independent random variables — from any distribution — and the sum approaches a normal distribution. This is why the bell curve appears everywhere: it is the attractor of repeated averaging. <em>The bell curve as inevitable convergence.</em>',
    pythonFile: 'central_limit.py',
  },
  {
    name: 'monte_carlo',
    title: 'Monte Carlo π',
    category: 'Statistical',
    description: 'Throw random darts at a square containing a circle. The fraction that land inside the circle approximates π/4. With enough darts, π emerges from randomness — a famous demonstration that computation and probability are deeply connected. <em>π computed by throwing darts.</em>',
    pythonFile: 'monte_carlo.py',
  },
  {
    name: 'random_walk',
    title: 'Random Walk',
    category: 'Statistical',
    description: 'A particle moves one step in a random direction at each tick. In 1D and 2D it returns to its origin with probability 1. In 3D it escapes forever with probability ≈0.66. This threshold — recurrence in low dimensions, transience in high — has deep implications for physics and probability. <em>Return is certain in two dimensions. In three, you wander forever.</em>',
    pythonFile: 'random_walk.py',
  },
  {
    name: 'ising',
    title: 'Ising Model',
    category: 'Statistical',
    description: 'A lattice of spins — up or down — where neighbors prefer to align and temperature fights alignment. At the critical temperature Tc ≈ 2.27, the system sits at the boundary between order and disorder, developing clusters at every scale simultaneously. This is a phase transition. The same universality class appears in liquid-gas transitions. <em>The edge between order and chaos, made visible.</em>',
    pythonFile: 'ising.py',
  },
  {
    name: 'percolation',
    title: 'Percolation',
    category: 'Statistical',
    description: 'Each cell is open with probability p. Is there a connected path from top to bottom? Below the critical threshold pc ≈ 0.593, no path exists. Above it, paths are everywhere. Exactly at pc, the spanning cluster appears for the first time — and has fractal structure at every scale. The same threshold governs forest fires, epidemics, and flow through porous rock. <em>The moment a path first crosses.</em>',
    pythonFile: 'percolation.py',
  },
  {
    name: 'sandpile',
    title: 'Sandpile (Self-Organized Criticality)',
    category: 'Statistical',
    description: 'Drop grains of sand one at a time onto a grid. When any cell has 4 or more, it topples: loses 4, each neighbor gains 1. Without any external tuning, the system self-organizes to a critical state where avalanches follow a power law — small ones constantly, large ones rarely but inevitably. Per Bak (1987): this may be why earthquakes, extinctions, and market crashes share the same statistical structure. <em>A system that finds its own critical point.</em>',
    pythonFile: 'sandpile.py',
  },
  // Fractals (additional)
  {
    name: 'chaos_game',
    title: 'Chaos Game',
    category: 'Fractal',
    description: 'Three vertices of a triangle. One rule: pick a random vertex, move halfway. Repeat 100,000 times. The result is the Sierpiński triangle — a fractal with infinite nested structure, fractal dimension ≈1.585, zero area. No triangle is built into the rule. The triangle is what the rule <em>does</em>. <em>Randomness, iterated, reveals structure.</em>',
    pythonFile: 'chaos_game.py',
  },
  {
    name: 'dragon',
    title: 'Dragon Curve',
    category: 'Fractal',
    description: 'Fold a strip of paper in half repeatedly, always the same direction. Unfold each crease to 90°. The result is the dragon curve — a path that never crosses itself, becomes increasingly intricate at every order, and at high iterations begins to fill a region of the plane. Four dragon curves rotated 90° each tile the plane exactly. <em>Paper folding, iterated, produces a fractal.</em>',
    pythonFile: 'dragon.py',
  },
  {
    name: 'hilbert',
    title: 'Hilbert Curve',
    category: 'Fractal',
    description: 'A path — one-dimensional — that at the limit visits every point in a two-dimensional square. At each iteration, every segment is replaced by four folded into a U-shape. The limit curve has infinite length, positive area, and is continuous everywhere but differentiable nowhere. Cantor proved a line and a plane have the same number of points. Hilbert showed how to connect them continuously. <em>A line that fills a plane.</em>',
    pythonFile: 'hilbert.py',
  },
  {
    name: 'koch',
    title: 'Koch Snowflake',
    category: 'Fractal',
    description: 'Start with a triangle. Replace the middle third of every edge with a triangular bump. Repeat. The perimeter multiplies by 4/3 at each step — diverging to infinity. The area converges. After infinitely many iterations: a shape you can fill a bucket from, but whose edge has infinite length. <em>Finite area. Infinite perimeter. Bounded. Traceable by eye.</em>',
    pythonFile: 'koch.py',
  },
  {
    name: 'dla',
    title: 'Diffusion-Limited Aggregation',
    category: 'Fractal',
    description: 'Particles are released from the boundary and random-walk until they touch the growing cluster. The tips intercept incoming particles before the interior can — so tips grow faster, making new tips. This feedback produces branching at every scale: fractal dimension ≈1.71. The same process makes lightning channels, river deltas, frost on glass, and mineral dendrites. <em>Brownian motion builds a fractal.</em>',
    pythonFile: 'dla.py',
  },
  // Mathematical (additional)
  {
    name: 'fourier',
    title: 'Fourier Series',
    category: 'Mathematical',
    description: 'A square wave has sharp corners. A sine wave has none. Can you build a square wave from sines? Almost: the Fourier series adds odd harmonics (sin x, sin 3x, sin 5x…), each smaller than the last. As harmonics increase, the corners sharpen — but a 9% overshoot persists at every discontinuity, forever. This is the Gibbs phenomenon. The square wave is the limit. The limit is never reached. <em>Every timbre is a sum of sines.</em>',
    pythonFile: 'fourier.py',
  },
  {
    name: 'chladni',
    title: 'Chladni Figures',
    category: 'Mathematical',
    description: 'A metal plate covered in sand, bowed at its edge, vibrates at a resonant frequency. Sand migrates to the nodal lines — where the plate is still. The pattern is determined entirely by the vibrational mode (m, n). Chladni demonstrated this to Napoleon in 1809; Napoleon offered a prize for the explanation. Sophie Germain solved it on her fourth attempt. <em>Sound made visible in sand.</em>',
    pythonFile: 'chladni.py',
  },
  {
    name: 'lissajous',
    title: 'Lissajous Figures',
    category: 'Mathematical',
    description: 'x(t) = sin(a·t + δ), y(t) = sin(b·t). Two perpendicular sine waves trace a curve whose shape encodes the frequency ratio. An oscilloscope connected to two AC signals shows this pattern — and the shape tells you the ratio. The James Webb Space Telescope orbits in a Lissajous path around the L2 Lagrange point. When the ratio is irrational, the curve never closes, filling a rectangle densely. <em>The shape encodes the ratio.</em>',
    pythonFile: 'lissajous.py',
  },
  {
    name: 'voronoi',
    title: 'Voronoi Diagram',
    category: 'Mathematical',
    description: 'Given seed points, partition the plane: each location belongs to its nearest seed. The result is a tiling where every boundary is equidistant from two seeds. This structure appears in the cells of a leaf, a giraffe\'s coat, a dragonfly\'s eye, soap bubble packing, and geographic catchment areas — not by design, but because proximity always produces this pattern. <em>Nearest wins. The territory follows.</em>',
    pythonFile: 'voronoi.py',
  },
  {
    name: 'weierstrass',
    title: 'Weierstrass Function',
    category: 'Mathematical',
    description: 'f(x) = Σ aⁿ·cos(bⁿπx). This function is continuous everywhere and differentiable nowhere. Before Weierstrass (1872), mathematicians assumed continuity and smoothness were nearly the same. He shocked everyone by constructing a function with no tangent anywhere. Hermite called it "a lamentable evil." Later it was found that most continuous functions share this property. The monster was the normal case. <em>Continuous everywhere. Smooth nowhere.</em>',
    pythonFile: 'weierstrass.py',
  },
  // Probability & Information Theory
  {
    name: 'bayes',
    title: 'Bayesian Inference',
    category: 'Probability',
    description: 'A coin with unknown bias θ is flipped repeatedly. Each flip updates the posterior distribution over θ using Bayes\' theorem: multiply the prior by the likelihood, normalize. Watch the probability curve narrow and sharpen as evidence accumulates — converging on the true bias without ever being told what it is. <em>Rational belief updating is multiplication.</em>',
    pythonFile: 'bayes.py',
  },
  {
    name: 'entropy',
    title: 'Shannon Entropy',
    category: 'Information Theory',
    description: 'H = −Σ p·log₂(p). Entropy measures uncertainty — or equivalently, information content. A uniform distribution has maximum entropy: everything is equally surprising. A certain outcome has zero entropy: nothing is learned. Watch distributions morph between these extremes and see entropy rise and fall. Shannon named it entropy because "no one knows what entropy really is, so in a debate you will always have the advantage." <em>Information is surprise.</em>',
    pythonFile: 'entropy.py',
  },
  // Number Theory (additional)
  {
    name: 'continued_fractions',
    title: 'Continued Fractions',
    category: 'Number Theory',
    description: 'Every real number has a continued fraction expansion [a₀; a₁, a₂, ...]. The convergents — successive truncations — are the best rational approximations possible. φ = [1;1,1,1,...] is the hardest number to approximate (all ones). π = [3;7,15,1,292,...] has no visible pattern — an unsolved mystery. Watch convergents arriving and narrowing toward the true value. <em>The deepest representations of numbers.</em>',
    pythonFile: 'continued_fractions.py',
  },
  {
    name: 'gaussian_primes',
    title: 'Gaussian Primes',
    category: 'Number Theory',
    description: 'The Gaussian integers ℤ[i] = {a+bi : a,b ∈ ℤ} form a number system in the complex plane. A Gaussian prime cannot be factored in ℤ[i]. The ordinary prime 5 splits into (2+i)(2−i); but 3 stays prime. The pattern is fourfold symmetric — multiplying by i rotates 90°. <em>Primes in the complex integers have a different shape.</em>',
    pythonFile: 'gaussian_primes.py',
  },
  {
    name: 'totient',
    title: "Euler's Totient Function",
    category: 'Number Theory',
    description: 'φ(n) counts the integers from 1 to n that share no common factor with n. For primes p, φ(p) = p−1 (every smaller number qualifies). The scatter plot of (n, φ(n)) shows primes on the top edge, composites scattered below. Remarkably, the average ratio φ(n)/n converges to 6/π² — the same constant that governs the probability of two random integers being coprime. <em>The totient knows about π.</em>',
    pythonFile: 'totient.py',
  },
  {
    name: 'primes_visual',
    title: 'Prime Factorization',
    category: 'Number Theory',
    description: 'The Sieve of Eratosthenes, animated and colored by smallest prime factor: each prime marks its multiples, and those multiples inherit its color. Primes survive in amber — they were never crossed off. Composites glow in the color of their smallest divisor. Watch the grid fill as each prime claims its territory. <em>The primes as survivors of elimination.</em>',
    pythonFile: 'primes_visual.py',
  },
  // Algorithms
  {
    name: 'game_theory',
    title: "Prisoner's Dilemma Tournament",
    category: 'Game Theory',
    description: 'Five strategies — Tit-for-Tat, Always Cooperate, Always Defect, Grudger, Random — compete in a round-robin tournament over 200 rounds each. Defection tempts; cooperation pays if mutual. Watch scores accumulate and discover which strategy survives. Axelrod ran this tournament in 1980 and found Tit-for-Tat — the simplest cooperative strategy — wins. Nice, retaliatory, forgiving, clear. <em>Cooperation is the optimal strategy.</em>',
    pythonFile: 'game_theory.py',
  },
  {
    name: 'genetic',
    title: 'Genetic Algorithm',
    category: 'Algorithm',
    description: 'A population of bit strings evolves toward a hidden target: tournament selection picks fit parents, crossover mixes their genes, mutation flips random bits. No individual is told what the target is — fitness is the only signal. Watch the population converge generation by generation, fitness rising as a graph below. <em>Search by selection, crossover, mutation.</em>',
    pythonFile: 'genetic.py',
  },
  {
    name: 'huffman',
    title: 'Huffman Coding',
    category: 'Algorithm',
    description: 'Given symbol frequencies, Huffman\'s algorithm builds the optimal prefix-free code: merge the two rarest symbols into a combined node, repeat. Common symbols get short codes; rare symbols get long ones. The result is the minimum average code length possible without a codebook — the theoretical limit for symbol-by-symbol compression. Watch the tree assemble from the bottom up. <em>The optimal code, built greedily.</em>',
    pythonFile: 'huffman.py',
  },
  // Physics
  {
    name: 'traffic',
    title: 'Rule 184: Traffic',
    category: '1D Cellular Automaton',
    description: 'Rule 184 models single-lane traffic: a car (1) moves forward if the next cell is empty (0); otherwise it waits. At densities below 0.5, all cars flow freely. Above 0.5, traffic jams form and propagate backward — against the direction of travel. The jams are not caused by any individual car; they are a property of the density. <em>Traffic jams as backward-moving waves.</em>',
    pythonFile: 'traffic.py',
  },
  {
    name: 'wireframe_3d',
    title: '3D Rotating Wireframe',
    category: 'Mathematical',
    description: 'Three polyhedra rotate through perspective projection: a cube (8 vertices, 12 edges), an icosahedron (12 vertices, 30 edges — one of the five Platonic solids, composed entirely of equilateral triangles), and a torus (a surface of revolution with a hole). Lines are colored by depth — front edges bright, rear edges dim — so the three-dimensional structure reads without shadows. <em>Depth from perspective alone.</em>',
    pythonFile: 'wireframe_3d.py',
  },
  {
    name: 'double_slit',
    title: 'Double-Slit Interference',
    category: 'Physics',
    description: 'Two coherent wave sources at the slits produce ripples that add or cancel depending on path length. Where path lengths differ by a whole wavelength: constructive interference, bright band. By half a wavelength: destructive, dark band. The pattern is the same for water, light, and — most disturbingly — single electrons fired one at a time. The single particle interferes with itself. This has been confirmed. It has not been explained. <em>Each electron passes through both slits simultaneously.</em>',
    pythonFile: 'double_slit.py',
  },
  // Dynamical Systems
  {
    name: 'double_pendulum',
    title: 'Double Pendulum',
    category: 'Attractor',
    description: 'A single pendulum is predictable. Attach a second pendulum to the end of the first and the system becomes chaotic: two trajectories starting a fraction of a degree apart diverge exponentially. This shows three pendulums with nearly identical starting conditions — same initial angle ±0.001°. Watch their paths separate. The same physics. Completely different outcomes. <em>The simplest system that produces chaos.</em>',
    pythonFile: 'double_pendulum.py',
  },
  {
    name: 'rossler',
    title: 'Rössler Attractor',
    category: 'Attractor',
    description: 'The Lorenz system requires three nonlinear terms to produce chaos. Rössler (1976) achieved it with one. Three equations, one nonlinear term (xz), parameters a=b=0.2, c=5.7. The trajectory spirals out, folds back, and spirals again — never repeating, never escaping. Simpler than Lorenz, just as strange. <em>Chaos with minimal ingredients.</em>',
    pythonFile: 'rossler.py',
  },
  // Simulation
  {
    name: 'boids',
    title: 'Boids (Flocking)',
    category: 'Simulation',
    description: 'Craig Reynolds (1986) reproduced flocking behavior from three local rules: separation (don\'t crowd neighbors), alignment (steer toward average heading), cohesion (steer toward average position). Each boid knows only its nearby neighbors. No boid knows it\'s in a flock. The flock is what the rules produce. <em>A flock without a leader.</em>',
    pythonFile: 'boids.py',
  },
  {
    name: 'diffusion',
    title: 'Diffusion (Heat Equation)',
    category: 'Simulation',
    description: 'The heat equation ∂u/∂t = D·∇²u describes heat spreading through a medium — and also the diffusion of particles, concentration gradients, and probability distributions. Start with a concentrated hot spot; watch it spread into a Gaussian and eventually equilibrate. The equation is reversible in principle, irreversible in practice. <em>Heat spreads. It never un-spreads.</em>',
    pythonFile: 'diffusion.py',
  },
  {
    name: 'galton',
    title: 'Galton Board',
    category: 'Statistical',
    description: 'Francis Galton\'s bean machine (1894): balls fall through rows of pegs, bouncing left or right at each. With 12 rows, each ball makes 12 independent binary choices. The final distribution is binomial — which converges to the normal distribution. The bell curve emerges from purely local random decisions. <em>The normal distribution from a peg board.</em>',
    pythonFile: 'galton.py',
  },
  {
    name: 'erdos_renyi',
    title: 'Erdős-Rényi Random Graph',
    category: 'Mathematical',
    description: 'Start with n isolated nodes. Add edges randomly, each with probability p. At the critical threshold p = 1/n, a giant connected component abruptly appears — a single cluster containing a significant fraction of all nodes. Below this threshold: only small isolated clusters. Above it: one giant component dominates. This phase transition appears in networks from epidemics to the internet. <em>The sudden emergence of connectivity.</em>',
    pythonFile: 'erdos_renyi.py',
  },
  {
    name: 'spirograph',
    title: 'Spirograph',
    category: 'Mathematical',
    description: 'A point on (or inside) a small circle rolling around a larger one traces a hypotrochoid or epitrochoid. The shape depends entirely on the ratio of the radii and the offset of the tracing point. When the ratio is rational, the curve closes; when irrational, it fills a region densely. The toy produces mathematical curves that arise in planetary motion, engineering, and gear design. <em>Circles rolling on circles, drawing the world.</em>',
    pythonFile: 'spirograph.py',
  },
  // Algorithm
  {
    name: 'knight_tour',
    title: "Knight's Tour",
    category: 'Algorithm',
    description: "A chess knight must visit every square exactly once. This is an NP-complete problem in general — but Warnsdorff's heuristic (1823) solves it in linear time: always move to the square with the fewest onward moves. Watch the knight trace a Hamiltonian path across the board, the path growing from dark to bright. <em>A greedy heuristic that almost always works.</em>",
    pythonFile: 'knight_tour.py',
  },
  {
    name: 'sorting_network',
    title: 'Sorting Network',
    category: 'Algorithm',
    description: 'A sorting network is a fixed sequence of comparators — each swaps two wires if they\'re out of order. The structure is determined before any data arrives: the same sequence of comparators sorts any input. Bitonic sort uses 9 parallel layers for 16 inputs. Watch data flow through the fixed circuit, disorder becoming order through a predetermined structure. <em>Order from a fixed circuit.</em>',
    pythonFile: 'sorting_network.py',
  },
  {
    name: 'markov_text',
    title: 'Markov Chain',
    category: 'Mathematical',
    description: 'A Markov chain assigns to each state a probability distribution over its next state. The Markov property: the future depends only on the present, not the history. Visualized here as a network of states with weighted transitions, with a random walk in progress — each step chosen by the probabilities, each choice forgetting all history. <em>The future depends only on now.</em>',
    pythonFile: 'markov_text.py',
  },
  {
    name: 'penrose',
    title: 'Penrose Tiling',
    category: 'Mathematical',
    description: 'A Penrose tiling covers the plane with two tile shapes (here: thick and thin rhombuses) such that the pattern never repeats. It is aperiodic — no translation maps the tiling to itself — yet it is ordered, not random. The ratio of thick to thin tiles converges to the golden ratio φ. Discovered by Roger Penrose in 1974; it was later found in the structure of quasicrystals. <em>Order without repetition.</em>',
    pythonFile: 'penrose.py',
  },
  {
    name: 'life_patterns',
    title: "Conway's Life: Pattern Showcase",
    category: '2D Cellular Automaton',
    description: "A guided tour through Life's most famous patterns: the Glider (the simplest moving object), the Gosper Glider Gun (the first pattern with unbounded growth, found by Bill Gosper in 1970), the R-pentomino (5 cells that take 1,103 generations to stabilize), and Acorn (7 cells that grow for 5,206 generations before dying). Four patterns, four different fates from almost nothing. <em>Five cells. Five thousand generations.</em>",
    pythonFile: 'life_patterns.py',
  },
  // 2D Cellular Automata (additional)
  {
    name: 'cyclic_ca',
    title: 'Cyclic Cellular Automaton',
    category: '2D Cellular Automaton',
    description: 'Each cell has one of N states. One rule: if any neighbor is one state ahead (mod N), advance. This is rock-paper-scissors topology, applied locally. From sparse random seeds: nothing, then expanding waves, then interlocking spirals covering the entire grid. The same rule governs the Belousov-Zhabotinsky reaction — oscillating chemical waves in a petri dish. Dismissed as impossible in 1951. Confirmed 1961. <em>A chemical reaction in miniature.</em>',
    pythonFile: 'cyclic_ca.py',
  },
];

export const programsByName = Object.fromEntries(programs.map(p => [p.name, p]));
